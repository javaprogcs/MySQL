一、事务四大属性
 分别是原子性、一致性、隔离性、持久性

 1、原子性(Atomicity)
 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完成应用到数据库，如果操作失败则不能
 对数据库有任何影响
 2、一致性(Consistency)
 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。举例来
 说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次帐，事务结束后两个用户的钱相加起来应该还得是1000，
 者就是事务的一致性。
 3、隔离性(Isolation)
 隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务
 之间要相互隔离。关于事务的隔离性数据库提供了多种隔离级别
 4、持久性(Durability)
 持久性时指事务一旦被提交了，那么对数据库中的数据的改变就是永久性，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。例如
 我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务已经正确提交，
 即使这时候数据枯出现了问题，也必须要将我们的事务完全执行完成，否则的话就会造成我们虽然看到事务处理完毕，但是数据库因为故障而没有
 执行事务的重大错误。这是不允许的。

二、事务的隔离级别
    1、为什么要设置隔离级别
    在数据库操作中，在并发的情况下可能出现如下问题：
      更新丢失(Lost update)
      如果多个线程操作，基于同一个查询结构对表中的记录进行修改，那么后修改的记录将会覆盖前面修改的记录，前面的修改就丢失掉了，
      这就叫做更新丢失。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。
      第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。
      第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所作的操作丢失。

      解决方法：对行加锁，只允许并发一个更新事务。

      脏读
      脏读：A事务读取B事务尚未提交的数据并在此基本上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。

      解决方法：如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可以避免该问题。

      不可重复读(Reads)
      一个事务对同一行数据重复读取两次，但是却得到了不同的结果。事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据
      时得到与前一次不同的值

      解决办法：如果只有在修改事务完成提交之后才可以读取数据，则可以避免该问题。

      幻象读
      指两次执行同一条select语句会出现不同的结果，第二次读会增加一行数据，并没有说两次执行是在同一事务中。

      解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题。

2、事务的隔离级别
    数据库事务的隔离级别有4个，由低到高依次为
    Read uncommitted(未授权读取、读未提交)  如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此
    行数据。该隔离级别可以通过“排他写锁”实现。这样就避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。

    Read committed(授权读取、读提交)：读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。该
    隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据
    时，数据已经发生了改变。

    Repeatable read(可重复读)：可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，
    在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的数据是一样的。这样就发生了在一个事务内两次读到
    的数据是一样的。因此称为是可重复读。读取数据事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。这样避免了不可重复读取
    和脏读，但是有时可能出现幻读。(读取数据的事务)这可以通过“共享读锁”和“排他写锁”实现。

    Serializable(序列化)：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是
    无法实现事务序列化，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也花费最高，
    性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻象读。

    隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先把数据库系统的隔离级别设为Read
    Committed。它能避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的
    个别场合，可以由应用程序采用悲观锁或乐观锁来控制。大多数数据库的默认级别就是Read committed，比如Sql Server, Oracle。mysql 的默认隔离级别
    是可重复读(Repeatable read)

    1、悲观锁
    悲观锁，它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处理锁定状态。
    悲观锁的实现，往往依靠数据库提供的锁机制。也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统的数据访问层中实现了加锁机制，
    也无法保证外部系统不会修改数据

       使用场景举例：以Mysql InnoDB为例
       商品t_items表中有一个字段status,status为1代表商品未被下单,status为2代表商品被下单(此刻该商品无法再次下单)，那么我们对某个商品下单时
       必须确保该商品status为1。假设商品的id为1.
       如果不采用锁，那么操作方法如下：

       //1、查询出商品信息
       select status from t_items where id = 1;

       //2、根据商品信息生成订单，并插入订单表 t_orders
       insert into t_orders (id,goods_id) values (null,1);

       //3、修改商品status为2
       update t_items set status = 2;

       上面这种情景在高并发访问的情况下很可能会出现问题。例如当第一步操作中，查询出来的商品status为1。但是当我们执行第三步Update操作的时候，
       有可能出现其他人先一步对商品下单把t_items中的status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得
       数据不一致。所以说这种方式是不安全的。

       使用悲观锁来解决问题

       在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出t_items信息后就把当前的数据锁定，
       直到我们修改完毕后再解锁。那么在这个过程中，因为t_items被锁定了，就不会出现有第三者来对其进行修改了。需要注意的是，要是用悲观锁，我们必须
       关闭mysql数据库的自动提交属性，因为Mysql默认使用autocommit模式，也就是说，当你执行一个更新操作后，Mysql会立刻进行提交。我们可以使用命令设置
       Mysql为非autocommit模式: set autocommit = 0；

       //0、开始事务
       begin; /begin work; /start transaction; (三者选一就可以)

       //1、查询出商品信息
       select status from t_items where id = 1 for update;

       //2、根据商品信息生成订单
       insert into t_orders (id,goods_id) values (null,1);

       //3、修改商品status为2
       update t_items set status = 2;

       //4、提交事务
       commit; /commit work;

       悲观锁小结：悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度
       的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，
       这样的开销往往无法承受。所以与悲观锁相对的，我们有了乐观锁。

      2、乐观锁
      乐观锁相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以只会在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，
      如果发现冲突了，则返回用户错误的信息，让用户决定如何去做。实现乐观锁一般来说有以下2种方式：

            使用版本号

            使用数据版本(Version)记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表
            增加一个数字类型的 “version”字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新
            的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行对比，如果数据库表当前版本号与第一次取出来的version值相等，
            则予以更新，否则时过期数据。

            使用时间戳

            乐观锁的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳(timestamp),
            和上面的version类似，也就是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是
            版本号冲突